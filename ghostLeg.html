<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>爬梯子遊戲GHOST LEG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Bungee&family=Chocolate+Classical+Sans&display=swap" rel="stylesheet">
<style>

    body { font-family: 'Bungee', 'Chocolate Classical Sans', sans-serif; }
    .card {
        border-radius: 1rem; 
    }
    .btn { transition: all 0.2s ease-in-out; }
    .btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; box-shadow: none; }
    textarea { resize: vertical; }
    .end-point-label { transition: opacity 0.5s ease-in-out, color 0.5s ease-in-out, transform 0.3s ease; }
    .title-font { font-family: 'Bungee', sans-serif; }
    </style>
</head>
    <!--增加背景漸層顏色-->
<body class="flex justify-center items-center min-h-screen p-4 bg-gradient-to-b from-sky-100 to-slate-700">

    <div class="container max-w-4xl mx-auto">
        <!-- 設定畫面 -->
        <!-- 透明玻璃 -->
        <div id="setupView" class="card p-8 bg-white/25 backdrop-blur-lg shadow-lg">

            <h1 class="title-font text-5xl tracking-wider font-bold text-center text-slate-800">GHOST LEG</h1>
            <h2 class="text-3xl text-center text-slate-600 mb-8">爬梯子遊戲產生器</h2>
            <div class="space-y-4">
                <div>
                    <label for="startInputs" class=" lg:text-[20px] md:text-[15px] sm:text-[12px] block font-medium text-slate-700 font-normal">Enter starting points, one per line.</label>
                    <label for="startInputs" class=" lg:text-[18px] md:text-[13px] sm:text-[10px] block font-medium text-slate-800 opacity-75 leading-tight">起點名稱 (每行一個)</label>
                    <textarea id="startInputs" rows="5" class="lg:text-[20px] md:text-[15px] sm:text-[12px] mt-1 block w-full p-2 border border-slate-300 rounded-md">
阿美
阿坤
阿涵
阿喻
阿珮
                    </textarea>
                </div>
                <div>
                    <label for="endInputs" class="lg:text-[20px] md:text-[15px] sm:text-[12px]  block font-medium text-slate-700 font-normal">Enter destinations, one per line.</label>
                    <label for="endInputs" class="lg:text-[18px] md:text-[13px] sm:text-[10px] block font-medium text-slate-800 opacity-75 leading-tight">終點結果 (每行一個)</label>
                    <textarea id="endInputs" rows="5" class="lg:text-[20px] md:text-[15px] sm:text-[12px] mt-1 block w-full p-2 border border-slate-300 rounded-md">
PORSCHE
TOYOTA
MAZADA
TESLA
VOLKSWAGEN</textarea>
                </div>
                <button id="generateBtn" class="w-full btn bg-slate-700 text-white font-semibold py-3 rounded-lg shadow-md hover:bg-slate-700">
                    <div>
                        <span class="block text-lg leading-tight tracking-[5px]">產生梯子並開始遊戲</span>
                        <span class="block text-lg opacity-75 font-normal tracking-[3px]">Generate & Start Game</span>
                    </div>
                </button>
                <p id="setupError" class="text-red-500 text-center h-4"></p>
            </div>
        </div>

        <!-- 遊戲畫面 (預設隱藏) -->
        <div id="gameView" class="hidden text-center">
            <div id="start-points" class="relative mx-auto min-h-[50px]"></div>
            <canvas id="ladderCanvas" class="my-8 mx-auto block bg-white/35 backdrop-blur-lg shadow-lg rounded-2xl w-full max-w-[800px]"></canvas>
            <div id="end-points" class="relative mx-auto min-h-[50px]"></div>
            <div id="results" class="mt-2 text-2xl font-medium text-slate-300 h-16 flex flex-col items-center justify-center my-10"></div>
            <!-- RWD_CHANGE: 優化小螢幕按鈕排版，改為垂直堆疊 -->
            <div class="mt-4 flex flex-col sm:flex-row justify-center items-center space-y-4 sm:space-y-0 sm:space-x-4">
                <button id="showAllBtn" class="btn bg-sky-800 text-white font-semibold py-2 px-6 rounded-lg w-50">
                  <div>
                    <span class="block text-base leading-tight tracking-[3px]">顯示所有結果</span>  
                    <span class="block font-bold text-base opacity-75 font-normal tracking-[5px] ">SHOW All</span>
                  </div>
                </button>
                <button id="resetBtn" class="btn bg-pink-800 text-white font-semibold py-2 px-6 rounded-lg w-40">
                  <div>
                    <span class="block text-base leading-tight tracking-[3px]">全部重設</span>
                    <span class="block font-bold text-base opacity-75 font-normal tracking-[5px]">RESET</span>
                  </div>
                    
                  </button>
            </div>

            <!-- 結果彈窗 (Modal) -->
            <div id="summaryModal" class="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center p-4 z-50 hidden">
                <div id="summaryView" class="card p-6 bg-white/60 backdrop-blur-lg shadow-lg w-full max-w-md relative">
                    <button id="closeSummaryBtn" class="absolute top-2 right-3 text-2xl font-bold text-slate-600 hover:text-slate-800">&times;</button>
                    <h2 class="text-2xl font-bold text-center text-slate-600 mb-1">Final Results</h2>
                    <p class="text-xl font-bold text-center text-slate-600 mb-4 tracking-[5px]">最終結果</p>
                    <div class="overflow-x-auto">
                        <table class="w-full min-w-[300px] text-center">
                            <thead class="bg-slate-200 backdrop-blur-lg">
                                <tr>
                                    <th class="p-2 text-lg font-semibold text-slate-600">起點</th>
                                    <th class="p-2 text-lg font-semibold text-slate-600">對應結果</th>
                                </tr>
                            </thead>
                            <tbody id="summaryTableBody">
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const setupView = document.getElementById('setupView');
        const gameView = document.getElementById('gameView');
        const generateBtn = document.getElementById('generateBtn');
        const showAllBtn = document.getElementById('showAllBtn');
        const resetBtn = document.getElementById('resetBtn');
        const startInputs = document.getElementById('startInputs');
        const endInputs = document.getElementById('endInputs');
        const setupError = document.getElementById('setupError');
        
        const canvas = document.getElementById('ladderCanvas');
        const ctx = canvas.getContext('2d');
        const startPointsContainer = document.getElementById('start-points');
        const endPointsContainer = document.getElementById('end-points');
        const resultsContainer = document.getElementById('results');
        const summaryView = document.getElementById('summaryView');
        const summaryModal = document.getElementById('summaryModal');
        const summaryTableBody = document.getElementById('summaryTableBody');
        const closeSummaryBtn = document.getElementById('closeSummaryBtn');

        let animationFrameId;
        let currentGameResizeHandler = null;

        function openSummaryModal() {
            summaryModal.classList.remove('hidden');
        }

        function initializeGame(config) {
            startPointsContainer.innerHTML = '';
            endPointsContainer.innerHTML = '';
            resultsContainer.textContent = '';
            summaryModal.classList.add('hidden');
            summaryTableBody.innerHTML = '';
            showAllBtn.disabled = false;

            let completedPaths = [];
            let revealedResults = [];

            const tickSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.1 } }).toDestination();
            const finishSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0.5, release: 0.2 } }).toDestination();

            const { numLadders, startLabels, endLabels, rungs } = config;
            let PADDING; 
            const ANIMATION_DURATION = 1500;
            const PATH_COLORS = ['#984B4B', '#949449', '#7373B9', '#9F4D95', '#BB3D00', '#73BF00', '#4F4F4F', '#930000', '#D9006C', '#6F00D2'];

            let getX;

            function getPathCoordinates(startLadderIndex) {
                let currentLadder = startLadderIndex;
                const path = [{ x: getX(currentLadder), y: PADDING }];
                rungs.forEach(rung => {
                    if (rung.start === currentLadder) {
                        path.push({ x: getX(currentLadder), y: rung.y }); currentLadder = rung.end; path.push({ x: getX(currentLadder), y: rung.y });
                    } else if (rung.end === currentLadder) {
                        path.push({ x: getX(currentLadder), y: rung.y }); currentLadder = rung.start; path.push({ x: getX(currentLadder), y: rung.y });
                    }
                });
                path.push({ x: getX(currentLadder), y: canvas.height - PADDING });
                return { path:path, endPoint: currentLadder };
            }

            function drawSinglePath(path, color) {
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }
                ctx.stroke();
            }

            function redrawCanvas() {
                if (!getX) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.lineWidth = 4;
                ctx.strokeStyle = 'white';
                ctx.shadowBlur = 5;
                for (let i = 0; i < numLadders; i++) {
                    const x = getX(i);
                    ctx.beginPath(); ctx.moveTo(x, PADDING); ctx.lineTo(x, canvas.height - PADDING); ctx.stroke();
                }
                rungs.forEach(rung => {
                    const startX = getX(rung.start);
                    const endX = getX(rung.end);
                    ctx.beginPath();
                    ctx.moveTo(startX, rung.y);
                    ctx.lineTo(endX, rung.y);
                    ctx.stroke();
                });
                completedPaths.forEach(p => drawSinglePath(p.path, p.color));
            }
            
            function updateDimensionsAndPositions() {
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientWidth * (600 / 800);

                startPointsContainer.style.width = `${canvas.width}px`;
                endPointsContainer.style.width = `${canvas.width}px`;

                PADDING = Math.max(25, canvas.width * 0.08);

                const contentWidth = canvas.width - (PADDING * 2);
                const spacing = numLadders > 1 ? contentWidth / (numLadders - 1) : 0;
                getX = (index) => PADDING + (index * spacing);

                const elementWidth = Math.max(50, Math.min(96, spacing * 0.85));

                // Helper function to adjust font size dynamically
                function adjustFontSize(element) {
                    const maxFontSize = 14; // Corresponds to 'text-sm'
                    const minFontSize = 8;
                    let currentFontSize = maxFontSize;
                    element.style.fontSize = `${currentFontSize}px`; // Reset font size

                    // Loop to reduce font size until it fits
                    // Note: 'clientWidth' is used as it reflects the actual displayed width
                    while (element.scrollWidth > element.clientWidth && currentFontSize > minFontSize) {
                        currentFontSize -= 0.5;
                        element.style.fontSize = `${currentFontSize}px`;
                    }
                }

                document.querySelectorAll('.start-btn').forEach(button => {
                    const index = parseInt(button.dataset.index);
                    button.style.left = `${getX(index)}px`;
                    button.style.width = `${elementWidth}px`;
                    adjustFontSize(button); // Adjust font size after setting width
                });

                document.querySelectorAll('.end-point-label').forEach(label => {
                    const index = parseInt(label.dataset.index);
                    label.style.left = `${getX(index)}px`;
                    label.style.width = `${elementWidth}px`;
                    adjustFontSize(label); // Adjust font size after setting width
                });
                
                redrawCanvas();
            }


            function animatePath(path, color, onFinish) {
                let startTime = null;
                let lastPlayedSegment = -1;
                function frame(timestamp) {
                    if (!startTime) startTime = timestamp;
                    const elapsedTime = timestamp - startTime;
                    const progress = Math.min(elapsedTime / ANIMATION_DURATION, 1);

                    redrawCanvas();
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 5;
                    ctx.lineCap = 'round';

                    const totalLength = path.reduce((acc, p, i) => i > 0 ? acc + Math.sqrt(Math.pow(p.x - path[i-1].x, 2) + Math.pow(p.y - path[i-1].y, 2)) : acc, 0);
                    
                    const distanceToDraw = progress * totalLength;
                    let distanceCovered = 0;
                    ctx.moveTo(path[0].x, path[0].y);
                    for(let i=0; i < path.length - 1; i++){
                        const segStart = path[i];
                        const segEnd = path[i+1];
                        const segLength = Math.sqrt(Math.pow(segEnd.x - segStart.x, 2) + Math.pow(segEnd.y - segStart.y, 2));
                        if(distanceCovered + segLength >= distanceToDraw){
                            if (i > lastPlayedSegment) {
                                tickSynth.triggerAttackRelease("C4", "8n");
                                lastPlayedSegment = i;
                            }
                            const fraction = (distanceToDraw - distanceCovered) / segLength;
                            const currentX = segStart.x + (segEnd.x - segStart.x) * fraction;
                            const currentY = segStart.y + (segEnd.y - segStart.y) * fraction;
                            ctx.lineTo(currentX, currentY);
                            break;
                        }
                        distanceCovered += segLength;
                        ctx.lineTo(segEnd.x, segEnd.y);
                    }
                    ctx.stroke();
                    if (progress < 1) {
                        animationFrameId = requestAnimationFrame(frame);
                    } else {
                        onFinish();
                    }
                }
                animationFrameId = requestAnimationFrame(frame);
            }

            function showAllResults() {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                document.querySelectorAll('.start-btn').forEach(b => b.disabled = true);
                for (let i = 0; i < numLadders; i++) {
                    if (revealedResults.some(r => r.startIndex === i)) continue;
                    const { path, endPoint } = getPathCoordinates(i);
                    const pathColor = PATH_COLORS[i % PATH_COLORS.length];
                    completedPaths.push({ path, color: pathColor });
                    const startLabel = startLabels[i] || `起點 ${i+1}`;
                    const endLabel = endLabels[endPoint] || `終點 ${endPoint+1}`;
                    const winnerLabel = endPointsContainer.querySelector(`.end-point-label[data-index="${endPoint}"]`);
                        if (winnerLabel) {
                        winnerLabel.classList.replace('opacity-0', 'opacity-100');
                        winnerLabel.style.backgroundColor = pathColor;
                        winnerLabel.classList.add('font-bold','scale-110');
                    }
                    revealedResults.push({ startIndex: i, endIndex: endPoint, startLabel, endLabel });
                    const startButton = startPointsContainer.querySelector(`.start-btn[data-index="${i}"]`);
                    if (startButton) {
                        startButton.classList.replace('bg-sky-800/60', 'bg-slate-400');
                    }
                }
                redrawCanvas();
                renderSummaryTable();
                resultsContainer.innerHTML = `
                    <span class="block text-m text-slate-300 my-auto tracking-[3px]">Showing all results</span>
                    <span class="block text-m text-slate-300 my-auto tracking-[3px]">所有結果已顯示</span>`;
            }
            showAllBtn.onclick = showAllResults;

            function renderSummaryTable() {
                summaryTableBody.innerHTML = '';
                const sortedResults = revealedResults.sort((a, b) => a.startIndex - b.startIndex);
                sortedResults.forEach(result => {
                    const row = document.createElement('tr');
                    row.classList.add('border-b');
                    row.innerHTML = `<td class="p-3 break-words">${result.startLabel}</td><td class="p-3 break-words">${result.endLabel}</td>`;
                    summaryTableBody.appendChild(row);
                });
                if (revealedResults.length === numLadders) {
                    summaryModal.classList.remove('hidden');
                    const showAllBtnContent = showAllBtn.querySelector('div');
                    if (showAllBtnContent) {
                        showAllBtnContent.innerHTML = `
                            <span class="block text-base leading-tight tracking-[3px]">查看最終結果</span>  
                            <span class="block font-bold text-base opacity-75 font-normal tracking-[5px] ">VIEW SUMMARY</span>
                        `;
                    }
                    showAllBtn.onclick = openSummaryModal;
                    showAllBtn.disabled = false;
                }
            }
            
            for (let i = 0; i < numLadders; i++) {
                const button = document.createElement('button');
                button.textContent = startLabels[i] || `起點 ${i + 1}`;
                button.dataset.index = i;
                // RWD CHANGE: 移除 truncate class
                button.classList.add('start-btn', 'btn', 'bg-sky-800/60', 'text-white', 'font-semibold', 'py-2', 'px-2', 'text-sm', 'rounded-lg', 'shadow-lg', 'absolute');
                button.style.transform = 'translateX(-50%)';
                button.addEventListener('click', () => {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    document.querySelectorAll('.start-btn').forEach(b => b.disabled = true);
                    resultsContainer.textContent = '...';
                    
                    const { path, endPoint } = getPathCoordinates(i);
                    const pathColor = PATH_COLORS[i % PATH_COLORS.length];
                    
                    animatePath(path, pathColor, () => {
                        finishSynth.triggerAttackRelease("G4", "4n");
                        const startLabel = startLabels[i] || `起點 ${i+1}`;
                        const endLabel = endLabels[endPoint] || `終點 ${endPoint+1}`;
                        resultsContainer.textContent = `${startLabel}  ➜  ${endLabel}`;
                        
                        const winnerLabel = endPointsContainer.querySelector(`.end-point-label[data-index="${endPoint}"]`);
                        if (winnerLabel) {
                            winnerLabel.classList.replace('opacity-0', 'opacity-100');
                            winnerLabel.style.backgroundColor = pathColor;
                            winnerLabel.classList.add('font-bold', 'scale-110','text-base');
                        }

                        completedPaths.push({ path, color: pathColor });
                        if (!revealedResults.some(r => r.startIndex === i)) {
                            revealedResults.push({ startIndex: i, endIndex: endPoint, startLabel, endLabel });
                        }
                        renderSummaryTable();
                        
                        button.disabled = true;
                        button.classList.replace('bg-sky-800/60', 'bg-slate-400');

                        document.querySelectorAll('.start-btn').forEach(b => {
                            if (!b.classList.contains('bg-slate-400')) {
                                b.disabled = false;
                            }
                        });
                    });
                });
                startPointsContainer.appendChild(button);

                const endLabel = document.createElement('div');
                endLabel.textContent = endLabels[i] || `終點 ${i + 1}`;
                endLabel.dataset.index = i;
                // RWD CHANGE: 移除 truncate class
                endLabel.classList.add('font-medium', 'text-slate-100', 'end-point-label', 'opacity-0', 'absolute', 'px-2', 'py-1', 'text-sm', 'rounded-lg');
                endLabel.style.transform = 'translateX(-50%)';
                endPointsContainer.appendChild(endLabel);
            }

            currentGameResizeHandler = updateDimensionsAndPositions;
            window.addEventListener('resize', currentGameResizeHandler);
            
            updateDimensionsAndPositions();
        }

        generateBtn.addEventListener('click', () => {
            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                Tone.start();
            }
            const startLabels = startInputs.value.trim().split('\n').filter(l => l);
            const endLabels = endInputs.value.trim().split('\n').filter(l => l);

            if (startLabels.length < 2 || startLabels.length !== endLabels.length) {
                setupError.textContent = '錯誤：起點和終點的數量必須一致，且至少要有兩項！';
                return;
            }
            setupError.textContent = '';
            localStorage.setItem('ghostLegStartLabels', startInputs.value);
            localStorage.setItem('ghostLegEndLabels', endInputs.value);
            
            const numLadders = startLabels.length;
            const rungs = [];

            const containerWidth = document.querySelector('.container').clientWidth;
            const tempCanvasHeight = Math.min(containerWidth, 800) * (600 / 800);

            const rungCount = Math.floor(numLadders * 2.5);
            const RUNG_TOP_MARGIN = tempCanvasHeight * 0.2;
            const RUNG_BOTTOM_MARGIN = tempCanvasHeight * 0.2;
            const MIN_RUNG_V_SPACING = tempCanvasHeight * 0.06;
            const RUNG_AREA_HEIGHT = tempCanvasHeight - RUNG_TOP_MARGIN - RUNG_BOTTOM_MARGIN;

            const zoneHeight = RUNG_AREA_HEIGHT / rungCount;
            const availableStarts = Array.from({ length: numLadders - 1 }, (_, i) => i);

            for (let i = 0; i < rungCount; i++) {
                const zoneStartY = RUNG_TOP_MARGIN + i * zoneHeight;
                const y = zoneStartY + (Math.random() * zoneHeight * 0.8) + (zoneHeight * 0.1);
                const shuffledStarts = [...availableStarts].sort(() => Math.random() - 0.5);
                for (const start of shuffledStarts) {
                    const end = start + 1;
                    const tooClose = rungs.some(r => (r.start === start || r.end === start || r.start === end || r.end === end) && Math.abs(r.y - y) < MIN_RUNG_V_SPACING);
                    if (!tooClose) { rungs.push({ y, start, end }); break; }
                }
            }

            for (let i = 0; i < numLadders; i++) {
                const hasRung = rungs.some(r => r.start === i || r.end === i);
                if (!hasRung) {
                    let neighbor;
                    if (i === 0) {
                        neighbor = 1;
                    } else if (i === numLadders - 1) {
                        neighbor = i - 1;
                    } else {
                        neighbor = Math.random() < 0.5 ? i - 1 : i + 1;
                    }
                    const start = Math.min(i, neighbor);
                    const end = Math.max(i, neighbor);
                    const newRungY = RUNG_TOP_MARGIN + Math.random() * RUNG_AREA_HEIGHT;
                    rungs.push({ y: newRungY, start, end });
                }
            }

            const gameConfig = { numLadders, startLabels, endLabels, rungs: rungs.sort((a, b) => a.y - b.y) };

            if (currentGameResizeHandler) {
                window.removeEventListener('resize', currentGameResizeHandler);
            }

            setupView.classList.add('hidden');
            gameView.classList.remove('hidden');
            initializeGame(gameConfig);
        });
        
        resetBtn.addEventListener('click', () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            if (currentGameResizeHandler) {
                window.removeEventListener('resize', currentGameResizeHandler);
                currentGameResizeHandler = null;
            }

            gameView.classList.add('hidden');
            summaryModal.classList.add('hidden');
            if (showAllBtn) {
                const showAllBtnContent = showAllBtn.querySelector('div');
                if (showAllBtnContent) {
                    showAllBtnContent.innerHTML = `
                        <span class="block text-base leading-tight tracking-[3px]">顯示所有結果</span>  
                        <span class="block font-bold text-base opacity-75 font-normal tracking-[5px] ">SHOW All</span>
                    `;
                }
                showAllBtn.onclick = null;
            }
            setupView.classList.remove('hidden');
        });

        closeSummaryBtn.addEventListener('click', () => {
            summaryModal.classList.add('hidden');
        });
        
        function autoAdjustTextarea() {
            const startLines = startInputs.value.split('\n').length;
            const endLines = endInputs.value.split('\n').length;
            const maxLines = Math.max(startLines, endLines, 5);
            startInputs.rows = maxLines;
            endInputs.rows = maxLines;
        };

        function loadSavedInputs() {
            const savedStarts = localStorage.getItem('ghostLegStartLabels');
            const savedEnds = localStorage.getItem('ghostLegEndLabels');
            if (savedStarts) startInputs.value = savedStarts;
            if (savedEnds) endInputs.value = savedEnds;
            autoAdjustTextarea();
        }

        loadSavedInputs();
        startInputs.addEventListener('input', autoAdjustTextarea);
        endInputs.addEventListener('input', autoAdjustTextarea);
    </script>
</body>
</html>

